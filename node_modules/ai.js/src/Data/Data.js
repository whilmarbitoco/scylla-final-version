class Data {
    constructor (argument) {
        this.__rows = argument['rows'];
        this.__labels = argument['labels'];
        this.__labelName = argument['labelName'];
        this.__attributeNames = argument['attributeNames'];
        this.__attributeNameIndexMap = this.__attributeNames.reduce((pre, now, index) => {
            pre[now] = index;
            return pre;
        }, {});
        this.__labelCategories = this.__labels.reduce((pre, now) => {
            pre.add(now);
            return pre;
        }, new Set());
        
        this.__rows = this.__rows.map(row => row.map(value => isNaN(value) ? value : parseFloat(value)));

    }
    shuffle () {
        for (let i = this.size.rowNumber; i > 0; i--) {
            let j = Math.floor(Math.random() * i);
            [this.__rows[i - 1], this.__rows[j]] = [this.__rows[j], this.__rows[i - 1]];
            [this.__labels[i - 1], this.__labels[j]] = [this.__labels[j], this.__labels[i - 1]];
        }
    }
    split (argument) {
        var rowsList = [];
        for (let i = 0; i < argument.length; i++) {
            rowsList.push([]);
        }
        var labelsList = [];
        for (let i = 0; i < argument.length; i++) {
            labelsList.push([]);
        }
        var currentCount = 0;
        var totalCount = argument.reduce((pre, now) => pre + now);
        argument = argument.map(value => {
            currentCount += value;
            return currentCount / totalCount;
        });
        for (let i = this.size.rowNumber - 1; i >= 0; i--) {
            let rand = Math.random();
            for (let j = 0; j < argument.length; j++) {
                if (rand <= argument[j]) {
                    rowsList[j].push(this.__rows[i]);
                    labelsList[j].push(this.__labels[i]);
                    break;
                }
            }
        }
        var datum = rowsList.map((rows, index) => {
            let labels = labelsList[index];
            return Data.createData({rows, labels, attributeNames: this.__attributeNames, labelName: this.__labelName});
        });
        return datum;
    }
    help () {
        console.log('I\'m Data');
    }
};

Data.createData = function (argument) {
    var data = new Data(argument);
    var wrappedData = new Proxy(data, {
        get: function (target, name) {
            if ((typeof(name) == 'string') && !isNaN(name)) {
                let index = parseInt(name);
                return target.__rows[index];
            }

            if (name == 'size') {
                return {rowNumber: target.__rows.length, columnNumber: target.__attributeNames.length};
            }

            if (name == 'labels') {
                return target.__labels;
            }

            if (name in target) {
                return target[name];
            }

            var attributeIndex = target.__attributeNameIndexMap[name];
            return target.__rows.map(row => row[attributeIndex]);
        }
    });
    return wrappedData;
};

module.exports = Data;
